---
title: linux 常用命令-网络应用
date: 2018/02/27
categories:
- linux
tags:
- linux
- command
---

<!-- TOC -->

- [linux 常用命令-网络应用](#linux-常用命令-网络应用)
    - [curl](#curl)
        - [补充说明](#补充说明)
        - [语法](#语法)
        - [选项](#选项)
        - [实例](#实例)
    - [wget](#wget)
        - [补充说明](#补充说明-1)
        - [语法](#语法-1)
        - [选项](#选项-1)
        - [参数](#参数)
        - [实例](#实例-1)
    - [telnet](#telnet)
        - [补充说明](#补充说明-2)
        - [语法](#语法-2)
        - [选项](#选项-2)
        - [参数](#参数-1)
        - [实例](#实例-2)
    - [ip](#ip)
        - [补充说明](#补充说明-3)
        - [语法](#语法-3)
        - [选项](#选项-3)
        - [参数](#参数-2)
        - [实例](#实例-3)
    - [iptables](#iptables)
        - [补充说明](#补充说明-4)
        - [语法](#语法-4)
        - [选项](#选项-4)
        - [基本参数](#基本参数)
            - [命令选项输入顺序](#命令选项输入顺序)
            - [工作机制](#工作机制)
            - [防火墙的策略](#防火墙的策略)
            - [防火墙的策略](#防火墙的策略-1)
        - [实例](#实例-4)
            - [空当前的所有规则和计数](#空当前的所有规则和计数)
            - [配置允许ssh端口连接](#配置允许ssh端口连接)
            - [允许本地回环地址可以正常使用](#允许本地回环地址可以正常使用)
            - [设置默认的规则](#设置默认的规则)
            - [配置白名单](#配置白名单)
            - [开启相应的服务端口](#开启相应的服务端口)
            - [保存规则到配置文件中](#保存规则到配置文件中)
            - [列出已设置的规则](#列出已设置的规则)
            - [清除已有规则](#清除已有规则)
            - [删除已添加的规则](#删除已添加的规则)
            - [开放指定的端口](#开放指定的端口)
            - [屏蔽IP](#屏蔽ip)
            - [指定数据包出去的网络接口](#指定数据包出去的网络接口)
            - [查看已添加的规则](#查看已添加的规则)
            - [启动网络转发规则](#启动网络转发规则)
            - [端口映射](#端口映射)
            - [字符串匹配](#字符串匹配)
            - [阻止Windows蠕虫的攻击](#阻止windows蠕虫的攻击)
            - [防止SYN洪水攻击](#防止syn洪水攻击)

<!-- /TOC -->

# linux 常用命令-网络应用

## curl

利用URL规则在命令行下工作的文件传输工具

### 补充说明

**curl命令** 是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。

### 语法  

```
curl(选项)(参数)
```

### 选项  

<table border="0" cellpadding="0" cellspacing="0">

<tbody>
<tr><td>-a/--append</td><td>上传文件时，附加到目标文件</td></tr>
<tr><td>-A/--user-agent <string></td><td>设置用户代理发送给服务器</td></tr>
<tr><td>-anyauth</td><td>可以使用“任何”身份验证方法</td></tr>
<tr><td>-b/--cookie <name=string/file></td><td>cookie字符串或文件读取位置</td></tr>
<tr><td>     --basic</td><td>使用HTTP基本验证</td></tr>
<tr><td>-B/--use-ascii</td><td>使用ASCII /文本传输</td></tr>
<tr><td>-c/--cookie-jar <file></td><td>操作结束后把cookie写入到这个文件中</td></tr>
<tr><td>-C/--continue-at <offset></td><td>断点续传</td></tr>
<tr><td>-d/--data <data></td><td>HTTP POST方式传送数据</td></tr>
<tr><td>     --data-ascii <data></td><td>以ascii的方式post数据</td></tr>
<tr><td>     --data-binary <data></td><td>以二进制的方式post数据</td></tr>
<tr><td>     --negotiate</td><td>使用HTTP身份验证</td></tr>
<tr><td>     --digest</td><td>使用数字身份验证</td></tr>
<tr><td>     --disable-eprt</td><td>禁止使用EPRT或LPRT</td></tr>
<tr><td>     --disable-epsv</td><td>禁止使用EPSV</td></tr>
<tr><td>-D/--dump-header <file></td><td>把header信息写入到该文件中</td></tr>
<tr><td>     --egd-file <file></td><td>为随机数据(SSL)设置EGD socket路径</td></tr>
<tr><td>     --tcp-nodelay</td><td>使用TCP_NODELAY选项</td></tr>
<tr><td>-e/--referer</td><td>来源网址</td></tr>
<tr><td>-E/--cert <cert:[passwd]></td><td>客户端证书文件和密码 (SSL)</td></tr>
<tr><td>     --cert-type <type></td><td>证书文件类型 (DER/PEM/ENG) (SSL)</td></tr>
<tr><td>     --key <key></td><td>私钥文件名 (SSL)</td></tr>
<tr><td>     --key-type <type></td><td>私钥文件类型 (DER/PEM/ENG) (SSL)</td></tr>
<tr><td>     --pass <pass></td><td>私钥密码 (SSL)</td></tr>
<tr><td>     --engine <eng></td><td>加密引擎使用 (SSL). "--engine list" for list</td></tr>
<tr><td>     --cacert <file></td><td>CA证书 (SSL)</td></tr>
<tr><td>     --capath <directory></td><td>CA目录 (made using c_rehash) to verify peer against (SSL)</td></tr>
<tr><td>     --ciphers <list></td><td>SSL密码</td></tr>
<tr><td>     --compressed</td><td>要求返回是压缩的形势 (using deflate or gzip)</td></tr>
<tr><td>     --connect-timeout <seconds></td><td>设置最大请求时间</td></tr>
<tr><td>     --create-dirs</td><td>建立本地目录的目录层次结构</td></tr>
<tr><td>     --crlf</td><td>上传是把LF转变成CRLF</td></tr>
<tr><td>-f/--fail</td><td>连接失败时不显示http错误</td></tr>
<tr><td>     --ftp-create-dirs</td><td>如果远程目录不存在，创建远程目录</td></tr>
<tr><td>     --ftp-method [multicwd/nocwd/singlecwd]</td><td>控制CWD的使用</td></tr>
<tr><td>     --ftp-pasv</td><td>使用 PASV/EPSV 代替端口</td></tr>
<tr><td>     --ftp-skip-pasv-ip</td><td>使用PASV的时候,忽略该IP地址</td></tr>
<tr><td>     --ftp-ssl</td><td>尝试用 SSL/TLS 来进行ftp数据传输</td></tr>
<tr><td>     --ftp-ssl-reqd</td><td>要求用 SSL/TLS 来进行ftp数据传输</td></tr>
<tr><td>-F/--form <name=content></td><td>模拟http表单提交数据</td></tr>
<tr><td>     --form-string <name=string></td><td>模拟http表单提交数据</td></tr>
<tr><td>-g/--globoff</td><td>禁用网址序列和范围使用{}和[]</td></tr>
<tr><td>-G/--get</td><td>以get的方式来发送数据</td></tr>
<tr><td>-H/--header <line></td><td>自定义头信息传递给服务器</td></tr>
<tr><td>     --ignore-content-length</td><td>忽略的HTTP头信息的长度</td></tr>
<tr><td>-i/--include</td><td>输出时包括protocol头信息</td></tr>
<tr><td>-I/--head</td><td>只显示请求头信息</td></tr>
<tr><td>-j/--junk-session-cookies</td><td>读取文件进忽略session cookie</td></tr>
<tr><td>     --interface <interface></td><td>使用指定网络接口/地址</td></tr>
<tr><td>     --krb4 <level></td><td>使用指定安全级别的krb4</td></tr>
<tr><td>-k/--insecure</td><td>允许不使用证书到SSL站点</td></tr>
<tr><td>-K/--config</td><td>指定的配置文件读取</td></tr>
<tr><td>-l/--list-only</td><td>列出ftp目录下的文件名称</td></tr>
<tr><td>     --limit-rate <rate></td><td>设置传输速度</td></tr>
<tr><td>     --local-port<NUM></td><td>强制使用本地端口号</td></tr>
<tr><td>-m/--max-time <seconds></td><td>设置最大传输时间</td></tr>
<tr><td>     --max-redirs <num></td><td>设置最大读取的目录数</td></tr>
<tr><td>     --max-filesize <bytes></td><td>设置最大下载的文件总量</td></tr>
<tr><td>-M/--manual</td><td>显示全手动</td></tr>
<tr><td>-n/--netrc</td><td>从netrc文件中读取用户名和密码</td></tr>
<tr><td>     --netrc-optional</td><td>使用 .netrc 或者 URL来覆盖-n</td></tr>
<tr><td>     --ntlm</td><td>使用 HTTP NTLM 身份验证</td></tr>
<tr><td>-N/--no-buffer</td><td>禁用缓冲输出</td></tr>
<tr><td>-o/--output</td><td>把输出写到该文件中</td></tr>
<tr><td>-O/--remote-name</td><td>把输出写到该文件中，保留远程文件的文件名</td></tr>
<tr><td>-p/--proxytunnel</td><td>使用HTTP代理</td></tr>
<tr><td>     --proxy-anyauth</td><td>选择任一代理身份验证方法</td></tr>
<tr><td>     --proxy-basic</td><td>在代理上使用基本身份验证</td></tr>
<tr><td>     --proxy-digest</td><td>在代理上使用数字身份验证</td></tr>
<tr><td>     --proxy-ntlm</td><td>在代理上使用ntlm身份验证</td></tr>
<tr><td>-P/--ftp-port <address></td><td>使用端口地址，而不是使用PASV</td></tr>
<tr><td>-q</td><td>作为第一个参数，关闭 .curlrc</td></tr>
<tr><td>-Q/--quote <cmd></td><td>文件传输前，发送命令到服务器</td></tr>
<tr><td>-r/--range <range></td><td>检索来自HTTP/1.1或FTP服务器字节范围</td></tr>
<tr><td>--range-file</td><td>读取（SSL）的随机文件</td></tr>
<tr><td>-R/--remote-time</td><td>在本地生成文件时，保留远程文件时间</td></tr>
<tr><td>     --retry <num></td><td>传输出现问题时，重试的次数</td></tr>
<tr><td>     --retry-delay <seconds></td><td>传输出现问题时，设置重试间隔时间</td></tr>
<tr><td>     --retry-max-time <seconds></td><td>传输出现问题时，设置最大重试时间</td></tr>
<tr><td>-s/--silent</td><td>静默模式。不输出任何东西</td></tr>
<tr><td>-S/--show-error</td><td>显示错误</td></tr>
<tr><td>     --socks4 <host[:port]></td><td>用socks4代理给定主机和端口</td></tr>
<tr><td>     --socks5 <host[:port]></td><td>用socks5代理给定主机和端口</td></tr>
<tr><td>     --stderr <file></td><td> </td></tr>
<tr><td>-t/--telnet-option <OPT=val></td><td>Telnet选项设置</td></tr>
<tr><td>     --trace <file></td><td>对指定文件进行debug</td></tr>
<tr><td>     --trace-ascii <file></td><td>Like --跟踪但没有hex输出</td></tr>
<tr><td>     --trace-time</td><td>跟踪/详细输出时，添加时间戳</td></tr>
<tr><td>-T/--upload-file <file></td><td>上传文件</td></tr>
<tr><td>     --url <URL></td><td>Spet URL to work with</td></tr>
<tr><td>-u/--user <user[:password]></td><td>设置服务器的用户和密码</td></tr>
<tr><td>-U/--proxy-user <user[:password]></td><td>设置代理用户名和密码</td></tr>
<tr><td>-w/--write-out [format]</td><td>什么输出完成后</td></tr>
<tr><td>-x/--proxy <host[:port]></td><td>在给定的端口上使用HTTP代理</td></tr>
<tr><td>-X/--request <command></td><td>指定什么命令</td></tr>
<tr><td>-y/--speed-time</td><td>放弃限速所要的时间，默认为30</td></tr>
<tr><td>-Y/--speed-limit</td><td>停止传输速度的限制，速度时间</td></tr>
</tbody>

</table>

### 实例  

**文件下载** 

curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作。如果系统没有curl可以使用`yum install curl`安装，也可以下载安装。curl是将下载文件输出到stdout，将进度信息输出到stderr，不显示进度信息使用`--silent`选项。

```
curl URL --silent
```

这条命令是将下载文件输出到终端，所有下载的数据都被写入到stdout。

使用选项`-O`将下载的数据写入到文件，必须使用文件的绝对地址：

```
curl http://man.linuxde.net/text.iso --silent -O
```

选项`-o`将下载数据写入到指定名称的文件中，并使用`--progress`显示进度条：

```
curl http://man.linuxde.net/test.iso -o filename.iso --progress
######################################### 100.0%
```

**断点续传** 

curl能够从特定的文件偏移处继续下载，它可以通过指定一个便宜量来下载部分文件：

```
curl URL/File -C 偏移量

#偏移量是以字节为单位的整数，如果让curl自动推断出正确的续传位置使用-C -：
curl -C -URL
```

**使用curl设置参照页字符串** 

参照页是位于HTTP头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页A中的某个连接，那么用户就会跳转到B网页，网页B头部的参照页字符串就包含网页A的URL。

使用`--referer`选项指定参照页字符串：

```
curl --referer http://www.google.com http://man.linuxde.net
```

**用curl设置cookies** 

使用`--cookie "COKKIES"`选项来指定cookie，多个cookie使用分号分隔：

```
curl http://man.linuxde.net --cookie "user=root;pass=123456"
```

将cookie另存为一个文件，使用`--cookie-jar`选项：

```
curl URL --cookie-jar cookie_file
```

**用curl设置用户代理字符串** 

有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用`--user-agent`或者`-A`选项：

```
curl URL --user-agent "Mozilla/5.0"
curl URL -A "Mozilla/5.0"
```

其他HTTP头部信息也可以使用curl来发送，使用`-H`"头部信息" 传递多个头部信息，例如：

```
curl -H "Host:man.linuxde.net" -H "accept-language:zh-cn" URL
```

**curl的带宽控制和下载配额** 

使用`--limit-rate`限制curl的下载速度：

```
curl URL --limit-rate 50k
```

命令中用k（千字节）和m（兆字节）指定下载速度限制。

使用`--max-filesize`指定可下载的最大文件大小：

```
curl URL --max-filesize bytes
```

如果文件大小超出限制，命令则返回一个非0退出码，如果命令正常则返回0。

**用curl进行认证** 

使用curl选项 -u 可以完成HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：

```
curl -u user:pwd http://man.linuxde.net
curl -u user http://man.linuxde.net
```

**只打印响应头部信息** 

通过`-I`或者`-head`可以只打印出HTTP头部信息：

```
[root@localhost text]# curl -I http://man.linuxde.net
HTTP/1.1 200 OK
Server: nginx/1.2.5
date: Mon, 10 Dec 2012 09:24:34 GMT
Content-Type: text/html; charset=UTF-8
Connection: keep-alive
Vary: Accept-Encoding
X-Pingback: http://man.linuxde.net/xmlrpc.php
```

**get请求**

```bash
curl "http://www.wangchujiang.com"    # 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地
curl -i "http://www.wangchujiang.com" # 显示全部信息
curl -l "http://www.wangchujiang.com" # 只显示头部信息
curl -v "http://www.wangchujiang.com" # 显示get请求全过程解析
```

**post请求**

```bash
curl -d "param1=value1&param2=value2" "http://www.wangchujiang.com"
```

**json格式的post请求**

```bash
curl -l -H "Content-type: application/json" -X POST -d '{"phone":"13521389587","password":"test"}' http://wangchujiang.com/apis/users.json
```

## wget

Linux系统下载文件工具

### 补充说明

**wget命令** 用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。

wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。

用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget虽然功能强大，但是使用起来还是比较简单：

1. **支持断点下传功能** 这一点，也是网络蚂蚁和FlashGet当年最大的卖点，现在，Wget也可以使用此功能，那些网络不是太好的用户可以放心了；
2. **同时支持FTP和HTTP下载方式** 尽管现在大部分软件可以使用HTTP方式下载，但是，有些时候，仍然需要使用FTP方式下载软件；
3. **支持代理服务器** 对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能；
4. **设置方便简单** 可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标；
5. **程序小，完全免费** 程序小可以考虑不计，因为现在的硬盘实在太大了；完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的。


### 语法  

```
wget [参数] [URL地址]
```

### 选项  

```
启动参数：

-V, –-version 显示wget的版本后退出
-h, –-help 打印语法帮助
-b, –-background 启动后转入后台执行
-e, –-execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc

记录和输入文件参数：

-o, –-output-file=FILE 把记录写到FILE文件中
-a, –-append-output=FILE 把记录追加到FILE文件中
-d, –-debug 打印调试输出
-q, –-quiet 安静模式(没有输出)
-v, –-verbose 冗长模式(这是缺省设置)
-nv, –-non-verbose 关掉冗长模式，但不是安静模式
-i, –-input-file=FILE 下载在FILE文件中出现的URLs
-F, –-force-html 把输入文件当作HTML格式文件对待
-B, –-base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–-sslcertfile=FILE 可选客户端证书
–-sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–-egd-file=FILE 指定EGD socket的文件名

下载参数：

–-bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –-tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –-output-document=FILE 把文档写到FILE文件中
-nc, –-no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –-continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –-timestamping 不要重新下载文件除非比本地文件新
-S, –-server-response 打印服务器的回应
–-spider 不下载任何东西
-T, –-timeout=SECONDS 设定响应超时的秒数
-w, –-wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –-proxy=on/off 打开或关闭代理
-Q, –-quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率

目录参数：

-nd –-no-directories 不创建目录
-x, –-force-directories 强制创建目录
-nH, –-no-host-directories 不创建主机目录
-P, –-directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录

HTTP 选项参数：

-–http-user=USER 设定HTTP用户名为 USER.
-–http-passwd=PASS 设定http密码为 PASS
-C, –-cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –-html-extension 将所有text/html文档以.html扩展名保存
-–ignore-length 忽略 `Content-Length’头域
-–header=STRING 在headers中插入字符串 STRING
-–proxy-user=USER 设定代理的用户名为 USER
-–proxy-passwd=PASS 设定代理的密码为 PASS
-–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –-save-headers 保存HTTP头到文件
-U, –-user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
-–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–-cookies=off 不使用 cookies
–-load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
-–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中

FTP 选项参数：

-nr, -–dont-remove-listing 不移走 `.listing’文件
-g, -–glob=on/off 打开或关闭文件名的 globbing机制
-–passive-ftp 使用被动传输模式 (缺省值).
-–active-ftp 使用主动传输模式
-–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)

递归下载参数：

-r, -–recursive 递归下载－－慎用!
-l, -–level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–-delete-after 在现在完毕后局部删除文件
-k, –-convert-links 转换非相对链接为相对链接
-K, –-backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –-mirror 等价于 -r -N -l inf -nr
-p, –-page-requisites 下载显示HTML文件的所有图片

递归下载中的包含和不包含(accept/reject)：

-A, –-accept=LIST 分号分隔的被接受扩展名的列表
-R, –-reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –-domains=LIST 分号分隔的被接受域的列表
–-exclude-domains=LIST 分号分隔的不被接受的域的列表
–-follow-ftp 跟踪HTML文档中的FTP链接
–-follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –-ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –-span-hosts 当递归时转到外部主机
-L, –-relative 仅仅跟踪相对链接
-I, –-include-directories=LIST 允许目录的列表
-X, –-exclude-directories=LIST 不被包含目录的列表
-np, –-no-parent 不要追溯到父目录
wget -S –-spider url 不下载只显示过程
```

### 参数  

URL：下载指定的URL地址。

### 实例  

 **使用wget下载单个文件** 

```
wget http://www.jsdig.com/testfile.zip
```

以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。

 **下载并以不同的文件名保存** 

```
wget -O wordpress.zip http://www.jsdig.com/download.aspx?id=1080
```

wget默认会以最后一个符合`/`的后面的字符来命令，对于动态链接的下载通常文件名会不正确。

错误：下面的例子会下载一个文件并以名称`download.aspx?id=1080`保存:

```
wget http://www.jsdig.com/download?id=1
```

即使下载的文件是zip格式，它仍然以`download.php?id=1080`命令。

正确：为了解决这个问题，我们可以使用参数`-O`来指定一个文件名：

```
wget -O wordpress.zip http://www.jsdig.com/download.aspx?id=1080
```

 **wget限速下载** 

```
wget --limit-rate=300k http://www.jsdig.com/testfile.zip
```

当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。

 **使用wget断点续传** 

```
wget -c http://www.jsdig.com/testfile.zip
```

使用`wget -c`重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用`-c`参数。

 **使用wget后台下载** 

```
wget -b http://www.jsdig.com/testfile.zip

Continuing in background, pid 1840.
Output will be written to `wget-log'.
```

对于下载非常大的文件的时候，我们可以使用参数`-b`进行后台下载，你可以使用以下命令来察看下载进度：

```
tail -f wget-log
```

 **伪装代理名称下载** 

```
wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.jsdig.com/testfile.zip
```

有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过`--user-agent`参数伪装。

 **测试下载链接** 

当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加`--spider`参数进行检查。

```
wget --spider URL
```

如果下载链接正确，将会显示:

```
Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Remote file exists and could contain further links,
but recursion is disabled -- not retrieving.
```

这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:

```
wget --spider url
Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 404 Not Found
Remote file does not exist -- broken link!!!
```

你可以在以下几种情况下使用`--spider`参数：

*   定时下载之前进行检查
*   间隔检测网站是否可用
*   检查网站页面的死链接

 **增加重试次数** 

```
wget --tries=40 URL
```

如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用`--tries`增加重试次数。

 **下载多个文件** 

```
wget -i filelist.txt
```

首先，保存一份下载链接文件：

```
cat > filelist.txt
url1
url2
url3
url4
```

接着使用这个文件和参数`-i`下载。

 **镜像网站** 

```
wget --mirror -p --convert-links -P ./LOCAL URL
```

下载整个网站到本地。

*   `--miror`开户镜像下载。
*   `-p`下载所有为了html页面显示正常的文件。
*   `--convert-links`下载后，转换成本地的链接。
*   `-P ./LOCAL`保存所有文件和目录到本地指定目录。

 **过滤指定格式下载** 

```
wget --reject=gif ur
```

下载一个网站，但你不希望下载图片，可以使用这条命令。

 **把下载信息存入日志文件** 

```
wget -o download.log URL
```

不希望下载信息直接显示在终端而是在一个日志文件，可以使用。

 **限制总下载文件大小** 

```
wget -Q5m -i filelist.txt
```

当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。

 **下载指定格式文件** 

```
wget -r -A.pdf url
```

可以在以下情况使用该功能：

*   下载一个网站的所有图片。
*   下载一个网站的所有视频。
*   下载一个网站的所有PDF文件。

 **FTP下载** 

```
wget ftp-url
wget --ftp-user=USERNAME --ftp-password=PASSWORD url
```

可以使用wget来完成ftp链接的下载。

使用wget匿名ftp下载：

```
wget ftp-url
```

使用wget用户名和密码认证的ftp下载：

```
wget --ftp-user=USERNAME --ftp-password=PASSWORD url
```

## telnet

登录远程主机和管理

### 补充说明

**telnet命令** 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。

### 语法  

```
telnet(选项)(参数)
```

### 选项  

```
-8：允许使用8位字符资料，包括输入与输出；
-a：尝试自动登入远端系统；
-b<主机别名>：使用别名指定远端主机名称；
-c：不读取用户专属目录里的.telnetrc文件；
-d：启动排错模式；
-e<脱离字符>：设置脱离字符；
-E：滤除脱离字符；
-f：此参数的效果和指定"-F"参数相同；
-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；
-k<域名>：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；
-K：不自动登入远端主机；
-l<用户名称>：指定要登入远端主机的用户名称；
-L：允许输出8位字符资料；
-n<记录文件>：指定文件记录相关信息；
-r：使用类似rlogin指令的用户界面；
-S<服务类型>：设置telnet连线所需的ip TOS信息；
-x：假设主机有支持数据加密的功能，就使用它；
-X<认证形态>：关闭指定的认证形态。
```

### 参数  

*   远程主机：指定要登录进行管理的远程主机；
*   端口：指定TELNET协议使用的端口号。

### 实例  

```
$ telnet 192.168.2.10
Trying 192.168.2.10...
Connected to 192.168.2.10 (192.168.2.10).
Escape character is '^]'.

    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)

login: root
Password: 
Login incorrect
```

一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。

```
$ telnet 192.168.188.132
Trying 192.168.188.132...
telnet: connect to address 192.168.188.132: Connection refused
telnet: Unable to connect to remote host
```

处理这种情况方法：

1. 确认ip地址是否正确？
1. 确认ip地址对应的主机是否已经开机？
1. 如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）
1. 如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）
1. 如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）

**启动telnet服务**

```
service xinetd restart
```

配置参数，通常的配置如下： 

```
service telnet 
{ 
    disable = no #启用 
    flags = REUSE #socket可重用 
    socket_type = stream #连接方式为TCP 
    wait = no #为每个请求启动一个进程 
    user = root #启动服务的用户为root 
    server = /usr/sbin/in.telnetd #要激活的进程 
    log_on_failure += USERID #登录失败时记录登录用户名 
} 
```

如果要配置允许登录的客户端列表，加入 
```
only_from = 192.168.0.2 #只允许192.168.0.2登录 
```
如果要配置禁止登录的客户端列表，加入 
```
no_access = 192.168.0.{2,3,4} #禁止192.168.0.2、192.168.0.3、192.168.0.4登录 
```
如果要设置开放时段，加入 
```
access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P） 
```

如果你有两个IP地址，一个是私网的IP地址如192.168.0.2，一个是公网的IP地址如218.75.74.83，如果你希望用户只能从私网来登录telnet服务，那么加入 
```
bind = 192.168.0.2 
```

各配置项具体的含义和语法可参考xined配置文件属性说明（man xinetd.conf） 

配置端口，修改services文件：

```
# vi /etc/services 
```

找到以下两句 

```
telnet 23/tcp 
telnet 23/udp 
```

如果前面有#字符，就去掉它。telnet的默认端口是23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将23这个数字修改掉，改成大一点的数字，比如61123。注意，1024以下的端口号是internet保留的端口号，因此最好不要用，还应该注意不要与其它服务的端口冲突。 

启动服务：
```
service xinetd restart 
```

## ip

网络配置工具

### 补充说明

**ip命令** 用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。

### 语法  

```
ip(选项)(参数)
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
       ip [ -force ] -batch filename
```

### 选项  

```
OBJECT := { link | address | addrlabel | route | rule | neigh | ntable |
       tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |
       netns | l2tp | macsec | tcp_metrics | token }
       
-V：显示指令版本信息；
-s：输出更详细的信息；
-f：强制使用指定的协议族；
-4：指定使用的网络层协议是IPv4协议；
-6：指定使用的网络层协议是IPv6协议；
-0：输出信息每条记录输出一行，即使内容较多也不换行显示；
-r：显示主机时，不使用IP地址，而使用主机的域名。
```

### 参数  

```
OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |
        -h[uman-readable] | -iec |
        -f[amily] { inet | inet6 | ipx | dnet | bridge | link } |
        -4 | -6 | -I | -D | -B | -0 |
        -l[oops] { maximum-addr-flush-attempts } |
        -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |
        -rc[vbuf] [size] | -n[etns] name | -a[ll] }
        
网络对象：指定要管理的网络对象；
具体操作：对指定的网络对象完成具体操作；
help：显示网络对象支持的操作命令的帮助信息。
```

### 实例  

```bash
ip link show                     # 显示网络接口信息
ip link set eth0 upi             # 开启网卡
ip link set eth0 down            # 关闭网卡
ip link set eth0 promisc on      # 开启网卡的混合模式
ip link set eth0 promisc offi    # 关闭网卡的混个模式
ip link set eth0 txqueuelen 1200 # 设置网卡队列长度
ip link set eth0 mtu 1400        # 设置网卡最大传输单元
ip addr show     # 显示网卡IP信息
ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1
ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址

ip route show # 显示系统路由
ip route add default via 192.168.1.254   # 设置系统默认路由
ip route list                 # 查看路由信息
ip route add 192.168.4.0/24  via  192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口
ip route add default via  192.168.0.254  dev eth0        # 设置默认网关为192.168.0.254
ip route del 192.168.4.0/24   # 删除192.168.4.0网段的网关
ip route del default          # 删除默认路由
ip route delete 192.168.1.0/24 dev eth0 # 删除路由
```

**用ip命令显示网络设备的运行状态** 

```
[root@localhost ~]# ip link list
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff
```

**显示更加详细的设备信息** 

```
[root@localhost ~]# ip -s link list
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    RX: bytes  packets  errors  dropped overrun mcast   
    5082831    56145    0       0       0       0      
    TX: bytes  packets  errors  dropped carrier collsns
    5082831    56145    0       0       0       0      
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:16:3e:00:1e:51 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    3641655380 62027099 0       0       0       0      
    TX: bytes  packets  errors  dropped carrier collsns
    6155236    89160    0       0       0       0      
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:16:3e:00:1e:52 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    2562136822 488237847 0       0       0       0      
    TX: bytes  packets  errors  dropped carrier collsns
    3486617396 9691081  0       0       0       0     
```

**显示核心路由表** 

```
[root@localhost ~]# ip route list 
112.124.12.0/22 dev eth1  proto kernel  scope link  src 112.124.15.130
10.160.0.0/20 dev eth0  proto kernel  scope link  src 10.160.7.81
192.168.0.0/16 via 10.160.15.247 dev eth0
172.16.0.0/12 via 10.160.15.247 dev eth0
10.0.0.0/8 via 10.160.15.247 dev eth0
default via 112.124.15.247 dev eth1
```

**显示邻居表** 

```
[root@localhost ~]# ip neigh list
112.124.15.247 dev eth1 lladdr 00:00:0c:9f:f3:88 REACHABLE
10.160.15.247 dev eth0 lladdr 00:00:0c:9f:f2:c0 STALE
```

**获取主机所有网络接口**

```
ip link | grep ^[0-9] | awk -F: '{print $2}'
```

## iptables

Linux上常用的防火墙软件

### 补充说明

**iptables命令** 是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。

### 语法  

```
iptables(选项)(参数)
```

### 选项  

```bash
-t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。

# 通用匹配：源地址目标地址的匹配
-p：指定要匹配的数据包协议类型；
-s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。
-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。
-i, --in-interface [!] <网络接口name> ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，"!" 表示取反。
-o, --out-interface [!] <网络接口name> ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。

# 查看管理命令
-L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。

# 规则管理命令
-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。
-I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。
-D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。
-R num：Replays替换/修改第几条规则

# 链管理命令（这都是立即生效的）
-P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。
-F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。
-N, --new-chain chain 用指定的名字创建一个新的链。
-X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。
-E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部照成任何影响。
-Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。

-j, --jump target <指定目标> ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。
-h：显示帮助信息；
```

### 基本参数

| 参数 | 作用 |
| ---- | ---- |
| -P |  设置默认策略:iptables -P INPUT (DROP|ACCEPT) |
| -F |  清空规则链 |
| -L |  查看规则链 |
| -A |  在规则链的末尾加入新规则 |
| -I | num  在规则链的头部加入新规则 |
| -D | num  删除某一条规则 |
| -s |  匹配来源地址IP/MASK，加叹号"!"表示除这个IP外。 |
| -d |  匹配目标地址 |
| -i | 网卡名称 匹配从这块网卡流入的数据 |
| -o | 网卡名称 匹配从这块网卡流出的数据 |
| -p |  匹配协议,如tcp,udp,icmp |
| --dport num | 匹配目标端口号 |
| --sport num | 匹配来源端口号 |

#### 命令选项输入顺序

```
iptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> -p 协议名 <-s 源IP/源子网> --sport 源端口 <-d 目标IP/目标子网> --dport 目标端口 -j 动作
```

#### 工作机制

规则链名包括(也被称为五个钩子函数（hook functions）)：

- **INPUT链** ：处理输入数据包。
- **OUTPUT链** ：处理输出数据包。
- **PORWARD链** ：处理转发数据包。
- **PREROUTING链** ：用于目标地址转换（DNAT）。
- **POSTOUTING链** ：用于源地址转换（SNAT）。

#### 防火墙的策略

防火墙策略一般分为两种，一种叫`通`策略，一种叫`堵`策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，`所以通，是要全通，而堵，则是要选择`。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。

我们现在用的比较多个功能有3个：

1. filter 定义允许或者不允许的，只能做在3个链上：INPUT ，FORWARD ，OUTPUT
2. nat 定义地址转换的，也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING
3. mangle功能:修改报文原数据，是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING

我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠mangle来实现的。
 
小扩展:

- 对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT
- 对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING
- 而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING
 
iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。 

iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。

注意：规则的次序非常关键，`谁的规则越严格，应该放的越靠前`，而检查规则的时候，是按照从上往下的方式进行检查的。

#### 防火墙的策略

防火墙策略一般分为两种，一种叫`通`策略，一种叫`堵`策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进，`所以通，是要全通，而堵，则是要选择`。

表名包括：

- **raw** ：高级功能，如：网址过滤。
- **mangle** ：数据包修改（QOS），用于实现服务质量。
- **net** ：地址转换，用于网关路由器。
- **filter** ：包过滤，用于防火墙规则。

动作包括：

- **ACCEPT** ：接收数据包。
- **DROP** ：丢弃数据包。
- **REDIRECT** ：重定向、映射、透明代理。
- **SNAT** ：源地址转换。
- **DNAT** ：目标地址转换。
- **MASQUERADE** ：IP伪装（NAT），用于ADSL。
- **LOG** ：日志记录。

```bash
                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓                         
 ┌───────────────┐           ┃    Network    ┃                         
 │ table: filter │           ┗━━━━━━━┳━━━━━━━┛                         
 │ chain: INPUT  │◀────┐             │                                 
 └───────┬───────┘     │             ▼                                 
         │             │   ┌───────────────────┐                       
  ┌      ▼      ┐      │   │ table: nat        │                       
  │local process│      │   │ chain: PREROUTING │                       
  └             ┘      │   └─────────┬─────────┘                       
         │             │             │                                 
         ▼             │             ▼              ┌─────────────────┐
┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅    │     ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      │table: nat       │
 Routing decision      └───── outing decision ─────▶│chain: PREROUTING│
┅┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅┅          ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      └────────┬────────┘
         │                                                   │         
         ▼                                                   │         
 ┌───────────────┐                                           │         
 │ table: nat    │           ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅               │         
 │ chain: OUTPUT │    ┌─────▶ outing decision ◀──────────────┘         
 └───────┬───────┘    │      ┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅                         
         │            │              │                                 
         ▼            │              ▼                                 
 ┌───────────────┐    │   ┌────────────────────┐                       
 │ table: filter │    │   │ chain: POSTROUTING │                       
 │ chain: OUTPUT ├────┘   └──────────┬─────────┘                       
 └───────────────┘                   │                                 
                                     ▼                                 
                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓                         
                             ┃    Network    ┃                         
                             ┗━━━━━━━━━━━━━━━┛                         
```


### 实例  

#### 空当前的所有规则和计数

```bash
iptables -F  # 清空所有的防火墙规则
iptables -X  # 删除用户自定义的空链
iptables -Z  # 清空计数
```

#### 配置允许ssh端口连接

```bash
iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT  
# 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求
```

#### 允许本地回环地址可以正常使用

```bash
iptables -A INPUT -i lo -j ACCEPT  
#本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许
iptables -A OUTPUT -o lo -j ACCEPT
```

#### 设置默认的规则

```bash
iptables -P INPUT DROP # 配置默认的不让进
iptables -P FORWARD DROP # 默认的不允许转发
iptables -P OUTPUT ACCEPT # 默认的可以出去
```

#### 配置白名单

```bash
iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口
```

#### 开启相应的服务端口

```bash
iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口
iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来
```

#### 保存规则到配置文件中

```bash
cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯
iptables-save > /etc/sysconfig/iptables 
cat /etc/sysconfig/iptables
```

#### 列出已设置的规则

> iptables -L [-t 表名] [链名]

- 四个表名 `raw`，`nat`，`filter`，`mangle`
- 五个规则链名 `INPUT`、`OUTPUT`、`FORWARD`、`PREROUTING`、`POSTROUTING`
- filter表包含`INPUT`、`OUTPUT`、`FORWARD`三个规则链

```bash
iptables -L -t nat                  # 列出 nat 上面的所有规则
#            ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个
iptables -L -t nat  --line-numbers  # 规则带编号
iptables -L INPUT

iptables -L -nv  # 查看，这个列表看起来更详细
```

#### 清除已有规则

```bash
iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则
iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。
                   # 如果没有指定链名，则会删除该表中所有非内置的链。
iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。
```

#### 删除已添加的规则

```bash
# 添加一条规则
iptables -A INPUT -s 192.168.1.5 -j DROP
```

将所有iptables以序号标记显示，执行：

```
iptables -L -n --line-numbers
```

比如要删除INPUT里序号为8的规则，执行：

```bash
iptables -D INPUT 8
```

#### 开放指定的端口

```
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行
iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口
iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口
iptables -A INPUT -j reject       #禁止其他未允许的规则访问
iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问
```

#### 屏蔽IP

```
iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8
iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令
iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令
iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令
iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是
```

#### 指定数据包出去的网络接口

只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。

```bash
iptables -A FORWARD -o eth0
```

#### 查看已添加的规则

```
iptables -L -n -v
Chain INPUT (policy DROP 48106 packets, 2690K bytes)
 pkts bytes target     prot opt in     out     source               destination         
 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           
 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22
1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80
4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED
 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)
 pkts bytes target     prot opt in     out     source               destination         
 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0  
```

#### 启动网络转发规则

公网`210.14.67.7`让内网`192.168.188.0/24`上网

```bash
iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127
```

#### 端口映射

本机的 2222 端口映射到内网 虚拟机的22 端口

```bash
iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22
```

#### 字符串匹配

比如，我们要过滤所有TCP连接中的字符串`test`，一旦出现它我们就终止这个连接，我们可以这么做：

```bash
iptables -A INPUT -p tcp -m string --algo kmp --string "test" -j REJECT --reject-with tcp-reset
iptables -L

# Chain INPUT (policy ACCEPT)
# target     prot opt source               destination        
# REJECT     tcp  --  anywhere             anywhere            STRING match "test" ALGO name kmp TO 65535 reject-with tcp-reset
#  
# Chain FORWARD (policy ACCEPT)
# target     prot opt source               destination        
#  
# Chain OUTPUT (policy ACCEPT)
# target     prot opt source               destination  
```

#### 阻止Windows蠕虫的攻击

```bash
iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string "cmd.exe"
```

#### 防止SYN洪水攻击

```bash
iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT
```